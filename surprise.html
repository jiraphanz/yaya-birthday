<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>üéÅ ‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÑ‡∏û‡∏£‡∏™‡πå</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      width: 100%;
      height: 100vh;
      background: linear-gradient(160deg, #ff9a9e 0%, #fad0c4 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: "Kanit", system-ui, sans-serif;
      overflow: hidden;
      animation: fadeIn 0.6s ease-out;
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    
    #canvas { display: block; }
    
    #hint {
      position: absolute;
      bottom: 40px;
      color: white;
      font-size: 32px;
      text-shadow: 0 2px 8px rgba(0,0,0,0.3);
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.6; } }
    
    #back-btn {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0,0,0,0.6);
      color: white;
      border: none;
      padding: 8px 14px;
      border-radius: 20px;
      cursor: pointer;
      font-family: "Kanit", sans-serif;
      font-size: 32px;
      z-index: 10;
      transition: all 0.3s;
    }
    #back-btn:hover { background: rgba(0,0,0,0.8); }
    
    .image-particle {
      position: fixed;
      width: 120px;
      height: 120px;
      background-size: cover;
      border-radius: 8px;
      pointer-events: none;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>
  <button id="back-btn">‚Üê ‡∏Å‡∏•‡∏±‡∏ö</button>
  <div id="hint">‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏™‡∏¥!üéÅ</div>

  <!-- Three.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
    // Image URLs
    const imageUrls = [
      '1.jpg', '2.jpg', '3.jpg', '4.jpg', '5.jpg'
    ];

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xff99a0);  // Pink gradient color

    const camera = new THREE.PerspectiveCamera(
      50,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 3, 4);  // Isometric view
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
    directionalLight.position.set(5, 8, 5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    // Box Material
    const boxMaterial = new THREE.MeshStandardMaterial({
      color: 0xd4a76a,  // Cardboard brown
      roughness: 0.7,
      metalness: 0
    });

    // Create BOX BODY - SMALLER
    const bodyGeometry = new THREE.BoxGeometry(1.5, 0.75, 1.1);
    const boxBody = new THREE.Mesh(bodyGeometry, boxMaterial);
    boxBody.position.y = 0.375;
    boxBody.castShadow = true;
    boxBody.receiveShadow = true;
    scene.add(boxBody);

    // Create LID - SMALLER
    const lidGeometry = new THREE.BoxGeometry(1.5, 0.1, 1.1);
    const lid = new THREE.Mesh(lidGeometry, boxMaterial);
    lid.position.set(0, 0, 0.55);  // Position at top
    lid.castShadow = true;
    lid.receiveShadow = true;

    // Pivot for lid rotation
    const lidPivot = new THREE.Object3D();
    lidPivot.position.set(0, 0.75, -0.55);  // Pivot point
    lidPivot.add(lid);
    scene.add(lidPivot);

    // Animation state
    let isOpen = false;
    let targetRotation = 0;
    let currentRotation = 0;
    let imageParticles = [];
    let shouldTransition = false;

    // Raycaster for clicking
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onClick(event) {
      if (shouldTransition) return;

      let clientX, clientY;
      
      // Handle both mouse and touch events
      if (event.touches) {
        clientX = event.touches[0].clientX;
        clientY = event.touches[0].clientY;
      } else if (event.changedTouches) {
        clientX = event.changedTouches[0].clientX;
        clientY = event.changedTouches[0].clientY;
      } else {
        clientX = event.clientX;
        clientY = event.clientY;
      }

      mouse.x = (clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects([boxBody, lidPivot], true);

      if (intersects.length > 0 && !isOpen) {
        openBox();
      }
    }

    function openBox() {
      isOpen = true;
      targetRotation = -Math.PI * 0.7;  // Open angle

      // Spawn particles
      burstImages();

      // Play sound
      playSound();

      // Transition
      setTimeout(() => {
        shouldTransition = true;
        setTimeout(() => {
          scene.background.setHex(0xffffff);
          setTimeout(() => {
            window.location.href = 'final.html';
          }, 300);
        }, 1000);
      }, 1500);
    }

    function burstImages() {
      imageUrls.forEach((url, i) => {
        setTimeout(() => {
          createImageParticle(url, i);
        }, i * 500);  // Much slower burst (500ms)
      });
    }

    function createImageParticle(url, index) {
      const particle = document.createElement('div');
      particle.className = 'image-particle';
      particle.style.backgroundImage = `url('${url}')`;
      particle.style.left = (window.innerWidth / 2) + 'px';
      particle.style.top = (window.innerHeight / 2) + 'px';
      particle.style.transform = 'translate(-50%, -50%)';
      document.body.appendChild(particle);

      // Alternate left and right
      const direction = index % 2 === 0 ? 1 : -1;  // 0,2,4 = right (+), 1,3 = left (-)
      const speed = 0.5 + Math.random() * 0.3;  // Even slower speed
      const vx = direction * speed;
      const vy = -0.5 + Math.random() * 0.2;  // Slightly upward with variation

      const p = {
        el: particle,
        x: 0,
        y: 0,
        vx: vx,
        vy: vy,
        ax: vx * -0.02,  // Even slower deceleration
        ay: 0.04,  // Even slower gravity
        rotation: Math.random() * 360,
        rotSpeed: Math.random() * 6 - 3,  // Slower rotation
        life: 1,
      };

      imageParticles.push(p);
    }

    function playSound() {
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const now = ctx.currentTime;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.15);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0, now + 0.15);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(now);
        osc.stop(now + 0.15);
      } catch (e) {}
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Smooth lid rotation - SLOWER (0.05 instead of 0.1)
      currentRotation += (targetRotation - currentRotation) * 0.05;
      lidPivot.rotation.x = currentRotation;

      // Update particles
      imageParticles.forEach(p => {
        p.vx += p.ax;
        p.vy += p.ay;
        p.x += p.vx;
        p.y += p.vy;
        p.rotation += p.rotSpeed;
        p.life -= 0.008;

        p.el.style.left = (window.innerWidth / 2 + p.x) + 'px';
        p.el.style.top = (window.innerHeight / 2 + p.y) + 'px';
        p.el.style.transform = `translate(-50%, -50%) rotate(${p.rotation}deg) scale(${p.life})`;
        p.el.style.opacity = p.life;

        if (p.life <= 0) p.el.remove();
      });

      imageParticles = imageParticles.filter(p => p.life > 0);

      // Transition - BIGGER ZOOM OUT (0.15 instead of 0.08)
      if (shouldTransition) {
        camera.position.z -= 0.15;
        camera.position.y -= 0.1;
      }

      renderer.render(scene, camera);
    }

    animate();

    // Events
    window.addEventListener('click', onClick);
    window.addEventListener('touchstart', onClick, { passive: false });
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    document.getElementById('back-btn').addEventListener('click', () => {
      if (!shouldTransition) window.location.href = 'index.html';
    });
  </script>
</body>
</html>
  <title>üéÅ ‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÑ‡∏û‡∏£‡∏™‡πå</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    body {
      background: linear-gradient(160deg, #ff9a9e 0%, #fad0c4 100%);
      font-family: "Kanit", system-ui, sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      animation: fadeIn 0.6s ease-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    /* Mobile-locked container */
    #mobile-frame {
      width: 100vw;
      height: 100vh;
      max-width: 420px;
      max-height: 100vh;
      background: transparent;
      position: relative;
      overflow: hidden;
      box-shadow: none;
      border-radius: 12px;
    }
    }
    #canvas-container {
      width: 100%;
      height: 100%;
      position: relative;
    }
    #hint {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      color: #333;
      font-size: 14px;
      pointer-events: none;
      animation: pulse 1.5s infinite;
      z-index: 5;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    #back-btn {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      border: none;
      padding: 8px 14px;
      border-radius: 20px;
      cursor: pointer;
      font-family: "Kanit", sans-serif;
      font-size: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      transition: all 0.3s;
      z-index: 10;
    }
    #back-btn:hover {
      background: rgba(0, 0, 0, 0.8);
      transform: translateY(-2px);
    }
    /* Image particles */
    .image-particle {
      position: absolute;
      width: 80px;
      height: 80px;
      background-size: cover;
      background-position: center;
      border-radius: 8px;
      pointer-events: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
  </style>
</head>
<body>
  <div id="mobile-frame">
    <button id="back-btn">‚Üê ‡∏Å‡∏•‡∏±‡∏ö</button>
    <div id="canvas-container"></div>
    <div id="hint">‡∏Å‡∏î‡∏ó‡∏µ‡πà‡∏Å‡∏•‡πà‡∏≠‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏¥‡∏î üéÅ</div>

  <!-- Three.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
    // Image URLs - Replace with actual image paths
    const imageUrls = [
      'image1.jpg',  // Replace with actual Yaya photo URL
      'image2.jpg',
      'image3.jpg',
      'image4.jpg',
      'image5.jpg',
    ];

    // === SCENE SETUP ===
    const mobileFrame = document.getElementById('mobile-frame');
    const canvasContainer = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xe8e8e8);  // Lighter gray background

    // Camera for mobile (1:1.5 aspect)
    const camera = new THREE.PerspectiveCamera(
      60,  // Wider FOV for isometric view
      1,  // mobile aspect ratio (will adjust)
      0.1,
      100
    );
    camera.position.set(4, 5, 4);  // Isometric angle

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    canvasContainer.appendChild(renderer.domElement);

    // Resize to fit mobile frame
    function resizeRenderer() {
      const width = mobileFrame.clientWidth;
      const height = mobileFrame.clientHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }
    resizeRenderer();

    // === LIGHTING ===
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);  // Increased intensity
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);  // Increased intensity
    dirLight.position.set(5, 10, 7);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    scene.add(dirLight);

    // Add a fill light from opposite side
    const fillLight = new THREE.DirectionalLight(0xffffff, 0.6);
    fillLight.position.set(-5, 3, -5);
    scene.add(fillLight);

    // === MATERIALS ===
    const boxMaterial = new THREE.MeshStandardMaterial({
      color: 0xd4a574,  // Brighter brown
      roughness: 0.3,   // Smoother
      metalness: 0.2,
    });

    const flapMaterial = new THREE.MeshStandardMaterial({
      color: 0xb8956a,  // Lighter flap color
      roughness: 0.4,
      metalness: 0,
    });

    // === BOX BODY ===
    const bodyGeo = new THREE.BoxGeometry(2.4, 1.2, 1.6);
    const boxBody = new THREE.Mesh(bodyGeo, boxMaterial);
    boxBody.position.y = 0.6;
    boxBody.castShadow = true;
    boxBody.receiveShadow = true;
    scene.add(boxBody);

    // === LID ===
    const lidGeo = new THREE.BoxGeometry(2.4, 0.16, 1.6);
    const lid = new THREE.Mesh(lidGeo, boxMaterial);
    lid.position.set(0, 0, 0.8);
    lid.castShadow = true;
    lid.receiveShadow = true;

    const lidPivot = new THREE.Object3D();
    lidPivot.position.set(0, 1.2, -0.8);
    lidPivot.add(lid);
    scene.add(lidPivot);

    // === SIDE FLAPS ===
    function createFlap(x, z) {
      const flapGeo = new THREE.BoxGeometry(0.12, 0.56, 1.44);
      const flap = new THREE.Mesh(flapGeo, flapMaterial);
      flap.position.set(x, 0.28, z);
      flap.castShadow = true;
      flap.receiveShadow = true;

      const flapPivot = new THREE.Object3D();
      flapPivot.position.set(x, 0.6, z);
      flap.position.set(0, -0.32, 0);
      flapPivot.add(flap);

      return { pivot: flapPivot, mesh: flap };
    }

    const flapLeft = createFlap(-1.12, 0);
    const flapRight = createFlap(1.12, 0);
    boxBody.add(flapLeft.pivot);
    boxBody.add(flapRight.pivot);

    // === ANIMATION STATE ===
    let isOpen = false;
    let targetLidRotation = 0;
    let currentLidRotation = 0;
    let targetFlapRotation = 0;
    let currentFlapRotation = 0;
    let imageParticles = [];
    let transitionStartTime = null;
    let shouldTransition = false;

    // === INTERACTION ===
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onInteraction(event) {
      if (shouldTransition) return;
      
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects([boxBody, lid]);
      
      if (intersects.length > 0 && !isOpen) {
        openBox();
      }
    }

    window.addEventListener('click', onInteraction);
    window.addEventListener('touchend', onInteraction);

    // === HOVER EFFECT ===
    let isHovering = false;
    function onMouseMove(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects([boxBody, lid]);
      isHovering = intersects.length > 0;
    }
    window.addEventListener('mousemove', onMouseMove);

    // === OPEN BOX & BURST IMAGES ===
    function openBox() {
      isOpen = true;
      targetLidRotation = -Math.PI / 1.5;
      targetFlapRotation = Math.PI / 6;

      // Spawn image particles
      burstImages();

      // Play sound
      playOpenSound();

      // Schedule transition after animation
      setTimeout(() => {
        shouldTransition = true;
        transitionStartTime = performance.now();
      }, 1500);
    }

    function burstImages() {
      imageUrls.forEach((url, i) => {
        setTimeout(() => {
          const particle = createImageParticle(url, i);
          imageParticles.push(particle);
        }, i * 200);  // Slower burst: 200ms spacing
      });
    }

    function createImageParticle(url, index) {
      const canvas = document.createElement('canvas');
      canvas.width = 160;
      canvas.height = 160;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#ddd';
      ctx.fillRect(0, 0, 160, 160);
      ctx.fillStyle = '#999';
      ctx.font = '40px Kanit';
      ctx.textAlign = 'center';
      ctx.fillText('Photo ' + (index + 1), 80, 80);

      const particle = document.createElement('div');
      particle.className = 'image-particle';
      particle.style.backgroundImage = `url('${url}')`;
      particle.style.left = '50%';
      particle.style.top = '50%';
      particle.style.transform = 'translate(-50%, -50%)';
      canvasContainer.appendChild(particle);

      const angle = (index / imageUrls.length) * Math.PI * 2;
      const speed = 1.2 + Math.random() * 0.8;  // Slower speed
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed - 1.2;  // Reduced upward force
      const ax = vx * -0.04;  // Slower deceleration
      const ay = 0.08;  // Slower gravity

      return {
        el: particle,
        x: 0,
        y: 0,
        vx: vx,
        vy: vy,
        ax: ax,
        ay: ay,
        rotation: Math.random() * 360,
        rotSpeed: Math.random() * 10 - 5,  // Slower rotation
        life: 1,
      };
    }

    // === SOUND EFFECT ===
    function playOpenSound() {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const now = audioContext.currentTime;

        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();

        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.15);

        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

        osc.connect(gain);
        gain.connect(audioContext.destination);

        osc.start(now);
        osc.stop(now + 0.15);
      } catch (e) {}
    }

    // === ANIMATION LOOP ===
    function animate() {
      requestAnimationFrame(animate);

      // Lid rotation
      const lidDelta = targetLidRotation - currentLidRotation;
      currentLidRotation += lidDelta * 0.1;
      lidPivot.rotation.x = currentLidRotation;

      // Flap rotation
      const flapDelta = targetFlapRotation - currentFlapRotation;
      currentFlapRotation += flapDelta * 0.08;
      flapLeft.pivot.rotation.z = currentFlapRotation;
      flapRight.pivot.rotation.z = -currentFlapRotation;

      // Hover scale
      const targetScale = isHovering && !isOpen ? 1.05 : 1;
      boxBody.scale.lerp(
        new THREE.Vector3(targetScale, targetScale, targetScale),
        0.1
      );

      // Box stays centered, no rotation

      // Update image particles
      imageParticles.forEach((p) => {
        p.vx += p.ax;
        p.vy += p.ay;
        p.x += p.vx;
        p.y += p.vy;
        p.rotation += p.rotSpeed;
        p.life -= 0.008;

        const containerWidth = canvasContainer.clientWidth;
        const containerHeight = canvasContainer.clientHeight;

        p.el.style.left = containerWidth / 2 + p.x + 'px';
        p.el.style.top = containerHeight / 2 + p.y + 'px';
        p.el.style.transform = `translate(-50%, -50%) rotate(${p.rotation}deg) scale(${p.life})`;
        p.el.style.opacity = p.life;

        if (p.life <= 0) {
          p.el.remove();
        }
      });

      imageParticles = imageParticles.filter((p) => p.life > 0);

      // Transition zoom effect
      if (shouldTransition && transitionStartTime) {
        const elapsed = performance.now() - transitionStartTime;
        const progress = Math.min(elapsed / 1000, 1);

        // Zoom in
        camera.position.z = 6 - progress * 5.5;
        camera.position.y = 3 - progress * 2.5;

        // Fade and navigate
        if (progress >= 1) {
          // Flash white
          scene.background.setHex(0xffffff);
          setTimeout(() => {
            window.location.href = 'final.html';
          }, 200);
        }
      }

      renderer.render(scene, camera);
    }

    animate();

    // === BACK BUTTON ===
    document.getElementById('back-btn').addEventListener('click', () => {
      if (!shouldTransition) {
        window.location.href = 'index.html';
      }
    });

    // === RESPONSIVE ===
    window.addEventListener('resize', resizeRenderer);
  </script>
  </div>
</body>
</html>